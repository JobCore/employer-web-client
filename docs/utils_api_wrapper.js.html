<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/api_wrapper.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/api_wrapper.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* global localStorage, fetch */
import { logout } from '../actions';
import log from './log';
import { Session } from 'bc-react-session';
import { setLoading } from '../components/load-bar/LoadBar.jsx';
// import { getCookie } from '../csrftoken';
import Cookies from 'js-cookie'


const rootAPIendpoint = process.env.API_HOST + '/api';

let HEADERS = {
  'Content-Type': 'application/json'
};

// TODO: implemente a queue for requests and status, also avoid calling the same request twice
let PendingReq = {
  _requests: [],
  add: function (req) {
    this._requests.push(req);
    setLoading(true);
  },
  remove: function (req) {
    this._requests = this._requests.filter(r => r !== req);
    if (this._requests.length == 0) {
      setLoading(false);
    }
  }
};

const getToken = () => {
  if (Session) {
    const payload = Session.getPayload();
    const token = payload.access_token;
    return token;
  }
  return null;
};

const appendCompany = (data) => {
  if (Session &amp;&amp; data) {
    const payload = Session.getPayload();
    data.employer = payload.user.profile.employer.id || payload.user.profile.employer;
    return data;
  }
};

/* AVAILABLE MODELS
  - badges
  - employees
  - employers
  - favlists
  - positions
  - profiles
  - shifts
  - venues
  - oauth/token (generate token)
  - tokenuser (get user data from local saved token)
*/

/**
 * Fetch JSON from API through GET method
 * @param {string} model Model data to be fetched. **Must be plural**
 * @returns {data}
 */
export const GET = async (endpoint, queryString = null, extraHeaders = {}) => {
  let url = `${rootAPIendpoint}/${endpoint}`;
  if (queryString) url += queryString;

  HEADERS['Authorization'] = `JWT ${getToken()}`;
  const REQ = {
    method: 'GET',
    headers: Object.assign(HEADERS, extraHeaders)
  };

  const req = new Promise((resolve, reject) => fetch(url, REQ)
    .then((resp) => processResp(resp, req))
    .then(data => resolve(data))
    .catch(err => {
      processFailure(err, req);
      reject(err);
    })
  );
  PendingReq.add(req);
  return req;
};

export const POST = (endpoint, postData, extraHeaders = {}) => {
  if (['user/register', 'login', 'user/password/reset','employers/me/jobcore-invites'].indexOf(endpoint) == -1) {
    HEADERS['Authorization'] = `JWT ${getToken()}`;
    postData = appendCompany(postData);
  }
  
  const REQ = {
    method: 'POST',
    headers: Object.assign(HEADERS, extraHeaders),
    body: JSON.stringify(postData),
    // mode: 'no-cors'
  };

  const req = new Promise((resolve, reject) => fetch(`${rootAPIendpoint}/${endpoint}`, REQ)
    .then((resp) => processResp(resp, req))
    .then(data => resolve(data))
    .catch(err => {
      processFailure(err, req);
      reject(err);
    })
  );

//   const req = new Promise((resolve, reject) => {
//     const loadData = async () => {
//       const res = await fetch(`${rootAPIendpoint}/${endpoint}`, REQ)
//       const data = await res.json();
//     }
//     loadData();
// });

  PendingReq.add(req);
  return req;
};
// function getCookie(name) {
//   let cookieValue = null;

//   if (document.cookie &amp;&amp; document.cookie !== '') {
//       const cookies = document.cookie.split(';');
//       for (let i = 0; i &lt; cookies.length; i++) {
//           const cookie = cookies[i].trim();

//           // Does this cookie string begin with the name we want?
//           if (cookie.substring(0, name.length + 1) === (name + '=')) {
//               cookieValue = decodeURIComponent(cookie.substring(name.length + 1));

//               break;
//           }
//       }
//   }

//   return cookieValue;
// }
// var csrftoken = getCookie('csrftoken');
// var headers = new Headers();
// headers.append('X-CSRFToken', csrftoken);
export const POSTcsrf = (endpoint, postData, extraHeaders = {}) => {
  // Cookies.get('csrftoken')
  // console.log("postData###", postData)
  Cookies.set('stripetoken', postData.id)
  if (['user/register', 'login', 'user/password/reset','employers/me/jobcore-invites'].indexOf(endpoint) == -1) {
    HEADERS['Authorization']  = `JWT ${getToken()}`,`X-CSRFToken ${Cookies.get('stripetoken')}`
    postData = appendCompany(postData);
  }

  const REQ = {
    method: 'POST',
    headers: Object.assign(HEADERS, extraHeaders),
    body: JSON.stringify(postData),
    // mode: 'no-cors'
  };
  const req = new Promise((resolve, reject) => fetch(`${rootAPIendpoint}/${endpoint}`, REQ)
    .then((resp) => processResp(resp, req))
    .then(data => resolve(data))
    .catch(err => {
      processFailure(err, req);
      reject(err);
    })
  );
  
  PendingReq.add(req);
  return req;
};

export const POSTcsrf2 = (endpoint, postData, extraHeaders = {}) => {
  // Cookies.get('csrftoken')
  // console.log("postData###", postData)
  // Cookies.set('stripetoken', postData.id)
  if (['user/register', 'login', 'user/password/reset','employers/me/jobcore-invites'].indexOf(endpoint) == -1) {
    HEADERS['Authorization']  = `JWT ${getToken()}`,`X-CSRFToken ${Cookies.get('stripetoken')}`
    postData = appendCompany(postData);
  }

  const REQ = {
    method: 'POST',
    headers: Object.assign(HEADERS, extraHeaders),
    body: JSON.stringify(postData),
    // mode: 'no-cors'
  };
  const req = new Promise((resolve, reject) => fetch(`${rootAPIendpoint}/${endpoint}`, REQ)
    .then((resp) => processResp(resp, req))
    .then(data => resolve(data))
    .catch(err => {
      processFailure(err, req);
      reject(err);
    })
  );
  
  PendingReq.add(req);
  return req;
};

// fetch('/api/upload', {
//     method: 'POST',
//     body: payload,
//     headers: headers,
//     credentials: 'include'
// }).  
export const PUTFiles = (endpoint, files) => {
  const headers = {
    'Authorization': `JWT ${getToken()}`
  };

  var fetchBody = new FormData();
  for (const file of files) fetchBody.append('image', file, file.name);

  const REQ = {
    headers,
    method: 'PUT',
    body: fetchBody
  };

  const req = new Promise((resolve, reject) => fetch(`${rootAPIendpoint}/${endpoint}`, REQ)
    .then((resp) => processResp(resp, req))
    .then(data => resolve(data))
    .catch(err => {
      processFailure(err, req);
      reject(err);
    })
  );
  PendingReq.add(req);

  return req;
};

export const PUT = (endpoint, putData, extraHeaders = {}) => {
  if (['register', 'login','user/password/reset'].indexOf(endpoint) == -1) {
    HEADERS['Authorization'] = `JWT ${getToken()}`;
  }
  const REQ = {
    method: 'PUT',
    headers: Object.assign(HEADERS, extraHeaders),
    body: JSON.stringify(putData)
  };

  const req = new Promise((resolve, reject) => fetch(`${rootAPIendpoint}/${endpoint}`, REQ)
    .then((resp) => processResp(resp, req))
    .then(data => resolve(data))
    .catch(err => {
      processFailure(err, req);
      reject(err);
    })
  );
  PendingReq.add(req);
  
  return req;
};

export const DELETE = (endpoint, extraHeaders = {}) => {
  HEADERS['Authorization'] = `JWT ${getToken()}`;

  const REQ = {
    method: 'DELETE',
    headers: Object.assign(HEADERS, extraHeaders)
  };

  const req = new Promise((resolve, reject) => fetch(`${rootAPIendpoint}/${endpoint}`, REQ)
    .then((resp) => processResp(resp, req))
    .then(data => resolve(data))
    .catch(err => {
      processFailure(err, req);
      reject(err);
    })
  );
  PendingReq.add(req);
  return req;
};

const processResp = function (resp, req = null) {
  PendingReq.remove(req);
  if (resp.ok) {
    if (resp.status == 204) return new Promise((resolve, reject) => resolve(true));
    else return resp.json();
  }
  else return new Promise(function (resolve, reject) {
    if (resp.status == 400) parseError(resp).catch((errorMsg) => reject(errorMsg));
    else if (resp.status == 404) reject(new Error('Not found'));
    else if (resp.status == 503) {
      logout();
      reject(new Error('The JobCore API seems to be unavailable'));
    }
    else if (resp.status == 401) {
      logout();
      reject(new Error('You are not authorized for this action'));
    }
    else if (resp.status >= 500 &amp;&amp; resp.status &lt; 600) {
      resp.json().then(err => reject(new Error(err.detail)))
        .catch((errorMsg) => reject(new Error('Something bad happened while completing your request! Please try again later.')));
    }
    else reject(new Error('Something went wrong'));
  });
};

const processFailure = function (err, req = null) {
  PendingReq.remove(req);
  log.error(err);
};

const parseError = (error) => new Promise(function (resolve, reject) {
  const errorPromise = error.json();
  errorPromise.then(json => {
    let errorMsg = '';
    for (let type in json) {
      if (Array.isArray(json[type])) errorMsg += json[type].join(',');
      else if (typeof json[type] === 'object' &amp;&amp; json[type] !== null) errorMsg += Object.values(json[type]).join(',');
      else errorMsg += json[type];
    }
    reject(errorMsg);
  })
    .catch(error => {
      reject(error);
    });
});</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">JSDoc of employer-web-client</a></h2><h3>Classes</h3><ul><li><a href="MakePayment.html">MakePayment</a></li><li><a href="Metrics.html">Metrics</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AddFavlistsToTalent">AddFavlistsToTalent</a></li><li><a href="global.html#ApplicantExtendedCard">ApplicantExtendedCard</a></li><li><a href="global.html#ApplicationDetails">ApplicationDetails</a></li><li><a href="global.html#BarChart">BarChart</a></li><li><a href="global.html#ClockInsDataGenerator">ClockInsDataGenerator</a></li><li><a href="global.html#ClockOutsDataGenerator">ClockOutsDataGenerator</a></li><li><a href="global.html#CreateDeduction">CreateDeduction</a></li><li><a href="global.html#createMapOptions">createMapOptions</a></li><li><a href="global.html#EditOrAddExpiredShift">EditOrAddExpiredShift</a></li><li><a href="global.html#EditOrAddShift">EditOrAddShift</a></li><li><a href="global.html#FeatureIndicator">FeatureIndicator</a></li><li><a href="global.html#fetchAllIfNull">fetchAllIfNull</a></li><li><a href="global.html#fetchPeyrollPeriodPayments">fetchPeyrollPeriodPayments</a></li><li><a href="global.html#FilterApplications">FilterApplications</a></li><li><a href="global.html#filterClockins">filterClockins</a></li><li><a href="global.html#FilterLocations">FilterLocations</a></li><li><a href="global.html#FilterShifts">FilterShifts</a></li><li><a href="global.html#FilterTalents">FilterTalents</a></li><li><a href="global.html#GeneralStats">GeneralStats</a></li><li><a href="global.html#GET">GET</a></li><li><a href="global.html#getDeductionsReport">getDeductionsReport</a></li><li><a href="global.html#getPaymentsReport">getPaymentsReport</a></li><li><a href="global.html#Hours">Hours</a></li><li><a href="global.html#HoursDataGenerator">HoursDataGenerator</a></li><li><a href="global.html#InviteTalentToJobcore">InviteTalentToJobcore</a></li><li><a href="global.html#InviteUserToCompanyJobcore">InviteUserToCompanyJobcore</a></li><li><a href="global.html#JobSeekers">JobSeekers</a></li><li><a href="global.html#JobSeekersDataGenerator">JobSeekersDataGenerator</a></li><li><a href="global.html#makeEmployeePayment">makeEmployeePayment</a></li><li><a href="global.html#NewJobSeekersDataGenerator">NewJobSeekersDataGenerator</a></li><li><a href="global.html#PendingInvites">PendingInvites</a></li><li><a href="global.html#PendingJobcoreInvites">PendingJobcoreInvites</a></li><li><a href="global.html#PendingRatings">PendingRatings</a></li><li><a href="global.html#PieChart">PieChart</a></li><li><a href="global.html#Punctuality">Punctuality</a></li><li><a href="global.html#Queue">Queue</a></li><li><a href="global.html#QueueData">QueueData</a></li><li><a href="global.html#RateShift">RateShift</a></li><li><a href="global.html#RatingDetails">RatingDetails</a></li><li><a href="global.html#RatingEmployees">RatingEmployees</a></li><li><a href="global.html#Ratings">Ratings</a></li><li><a href="global.html#ReviewTalentAndShift">ReviewTalentAndShift</a></li><li><a href="global.html#SearchShiftToInviteTalent">SearchShiftToInviteTalent</a></li><li><a href="global.html#SearchTalentToInviteToShift">SearchTalentToInviteToShift</a></li><li><a href="global.html#ShiftApplicants">ShiftApplicants</a></li><li><a href="global.html#ShiftDetails">ShiftDetails</a></li><li><a href="global.html#ShiftEmployees">ShiftEmployees</a></li><li><a href="global.html#ShiftInvites">ShiftInvites</a></li><li><a href="global.html#Shifts">Shifts</a></li><li><a href="global.html#ShiftsDataGenerator">ShiftsDataGenerator</a></li><li><a href="global.html#ShiftTalentClockins">ShiftTalentClockins</a></li><li><a href="global.html#TalentDetails">TalentDetails</a></li><li><a href="global.html#UpdateDeduction">UpdateDeduction</a></li><li><a href="global.html#updateProfileImage">updateProfileImage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Wed Oct 05 2022 17:57:01 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
